# 一、Go架构实践-微服务(微服务概览和治理)

## 1 微服务概览

### 1.1 单体架构

缺陷：应用复杂，应用无法扩展，可靠性低。

应对思路：

* 化简为繁，分而治之

### 1.2 微服务起源

SOA（面向服务）架构

SOA和微服务的关系：微服务是SOA的一种实践。

* 小即是美：小的服务代码少，bug也少，易测试，易维护
* 单一职责：一个服务也只需要做好一件事，专注才能做好。（utils、common）
* 尽可能早的创建原型：尽可能早的提供服务API。（前端可先mock数据）
* 可移植性比效率更重要：服务间的轻量级交互协议在效率和可移植性之间，首要依然考虑兼容性和移植性。

### 1.3 微服务定义

围绕业务功能构建，服务关注**单一业务**，服务间采用**轻量级**的通信机制，可以**全自动独立部署**，可以使用不同的编程语言和数据存储技术。微服务架构通过**业务**拆分实现**服务组件化**，通过组件组合快速开发系统，业务单一的服务组件又可以独立部署，使得整个系统变得清晰灵活。

* 原子服务
* 独立进程
* 隔离部署
* **去中心化服务治理**

缺点：

* 基础设施的建设、复杂度高

### 1.4 微服务的不足

> There are no silver bullets

* 微服务应用是分布式系统 --> 复杂性。

开发者不得不使用RPC或者消息传递，来实现进程间通信；此外，必须要写代码来处理消息传递中速度过慢或者服务不可用等局部失效问题。（粗粒度数据传输+并行）

* 分区的数据库架构。（一致性）
* 测试一个基于微服务架构的应用也是复杂的任务
* 服务模块间的依赖，应用升级有可能会波及多个服务模块的修改。
* 对运维基础设施的挑战比较大。

日志收集、报警

### 1.5 组件服务化

传统实现组件的方式是通过**库(library)**,库是和应用一起运行在进程中，**库的局部变化意味着整个应用的重新部署**。例如`ESB`。通过服务来实现组件，意味着将应用拆散为一系列的服务运行在不同的进程中，那么单一服务的局部变化只需重新部署对应的服务进程。我们用 Go 实施一个微服务。

* kit： 一个微服务的基础库（框架）。
* service：业务代码 + kit 依赖 + 第三方依赖组成的业务微服务
* rpc + message queue：轻量级通讯

*本质上等同于，多个微服务组合**(compose)**完成了一个完整*

*的用户场景**(usecase)**。（DDD）*

### 1.6 按业务组织服务（you built it,you fix it）

按业务能力组织服务的意思是服务提供的能力和业务功能对应，比如：订单服务和数据访问服务，前者反应了真实的订单相关业务，后者是一种技术抽象服务不反应真实的业务。所以按微服务架构理念来划分服务时，是不应该存在数据访问服务这样一个服务的。

事实上传统应用设计架构的分层结构正反应了不同角色的沟通结构。所以若要按微服务的方式来构建应用，也需要对应调整团队的组织架构。每个服务背后的小团队的组织是跨功能的，包含实现业务所需的全面的技能。



**闭环团队**

大前端**(**移动/Web)  --> 网关接入 --> 业务服务 --> 平台服务 --> 基础设施(PaaS/Saas)

### 1.7 去中心化

* 数据去中心化
* 治理去中心化
* 技术去中心化

### 1.8 基础设施自动化

无自动化不微服务，自动化包括测试和部署。单一进程的传统应用被拆分为一系列的多进程服务后，意味着**开发、调试、测试、监控和部署**的复杂度都会相应增大，必须要有合适的自动化基础设施来支持微服务架构模式，否则开发、运维成本将大大增加。

* `CICD`：`Gitlab` +` Gitlab Hooks` + `k8s`
* Testing: 测试环境、**单元测试**、API自动化测试
* 在线运行时：`k8s`，以及一系列`Prometheus`,`ELK`,`Control Panle`

### 1.9 可用性 & 兼容性设计(重要)

> *Be conservative in what you send, be liberal in what you accept.*
>
> *发送时要保守，接收时要开放。按照伯斯塔尔法则的思想来设计和实现服务时，发送的数据要更保守，*
>
> *意味着最小化的传送必要的信息，接收时更开放意味着要最大限度的容忍冗余数据，保证兼容性。*

著名的 `Design For Failure` 思想，微服务架构采用粗粒度的进程间通信，引入了额外的复杂性和需要处理的新问题，如**网络延迟、消息格式、负载均衡和容错**，忽略其中任何一点都属于对“分布式计算的误解”。

* 隔离
* 超时控制
* 负载保护
* 限流
* 降级
* 重试
* 负载均衡

一旦采用了微服务架构模式，那么在服务需要变更时我们要特别小心，服务提供者的变更可

能引发服务消费者的兼容性破坏，时刻谨记保持服务契约(接口)的兼容性。(API Design)



## 2 微服务设计

### 2.1 按照垂直功能拆分 （版本1）

* 客户端到微服务直接通信，强耦合。
* 需要多次请求，客户端聚合数据，工作量巨大，延迟高。
* 协议不利于统一，各个部门间有差异，需要端来兼容。
* 面向“端”的API适配，耦合到了内部服务。
* 多终端兼容逻辑复杂，每个服务都需要处理。
* 统一逻辑无法收敛，比如安全认证、限流。

### 2.2 App-Interface(BFF)(版本2)

App-Interface 用于统一的协议出口，在服务内进行大量的dataset join，按照业务场景来设计粗粒度的 API，给后续服务的演进带来的很多优势:

* 轻量交互：协议精简、聚合。

* 差异服务：数据裁剪以及聚合、针对终端定制化**API**。

* 动态升级：原有系统兼容升级，更新服务而非协议。

* 沟通效率提升，协作模式演进为移动业务**+**网关小组。

BFF (Backend For Frontend)可以认为是一种适配服务，将后端的微服务进行适配(主要包括聚合裁剪和格式适配等逻辑)向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。

最致命的一个问题是整个 App-Interface 属于**single point of failure**，严重代码缺陷或者流量洪峰可能引发集群宕机。

### 2.3 API Composer（版本3）

按业务分块聚合。

* 单个模块也会导致后续业务集成复杂度高，根据康威法则，单块的无限BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下。
*  很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，
  技术债越堆越多

### 2.4 跨横切面(Cross-Cutting Concerns) (版本4)

跨横切面(Cross-Cutting Concerns)的功能，需要协调更新框架升级发版(**路由、认证、限流、安全、日志**)，因此全部上沉，引入了 *API Gateway*，把业务集成度高的 BFF 层和通用功能服务层 *API Gateway* 进行了分层处理。

`Envoy` `Zuul` `Kong` `Apisix` `OR`

关注点分离*（Separation of Concerns)*。

BFF层专注业务数据聚合，API Gateway专注非业务功能。

移动端 -> API Gateway -> BFF -> Mircoservice，在FE Web业务中，BFF 可以是 nodejs 来做**服务端渲染**(SSR，Server-Side Rendering)，注意这里忽略了上游的 CDN、4(Lvs,F5,NetScaler)/7层负载均衡(ELB,Nginx)。

### 2.5 Microservice 划分



## 3 gRPC &服务发现

## 4 多集群 & 服务发现



